(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else {
        var a = factory();
        for (var i in a)(typeof exports === 'object' ? exports : root)[i] = a[i];
    }
})(typeof self !== 'undefined' ? self : this, function() {
    return /******/ (function(modules) { // webpackBootstrap
        /******/ // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/ // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/
            if (installedModules[moduleId]) {
                /******/
                return installedModules[moduleId].exports;
                /******/
            }
            /******/ // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: false,
                /******/
                exports: {}
                /******/
            };
            /******/
            /******/ // Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ // Flag the module as loaded
            /******/
            module.l = true;
            /******/
            /******/ // Return the exports of the module
            /******/
            return module.exports;
            /******/
        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;
        /******/
        /******/ // expose the module cache
        /******/
        __webpack_require__.c = installedModules;
        /******/
        /******/ // define getter function for harmony exports
        /******/
        __webpack_require__.d = function(exports, name, getter) {
            /******/
            if (!__webpack_require__.o(exports, name)) {
                /******/
                Object.defineProperty(exports, name, {
                    /******/
                    configurable: false,
                    /******/
                    enumerable: true,
                    /******/
                    get: getter
                    /******/
                });
                /******/
            }
            /******/
        };
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/
        __webpack_require__.n = function(module) {
            /******/
            var getter = module && module.__esModule ?
                /******/
                function getDefault() {
                    return module['default'];
                } :
                /******/
                function getModuleExports() {
                    return module;
                };
            /******/
            __webpack_require__.d(getter, 'a', getter);
            /******/
            return getter;
            /******/
        };
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/
        /******/ // __webpack_public_path__
        /******/
        __webpack_require__.p = "";
        /******/
        /******/ // Load entry module and return exports
        /******/
        return __webpack_require__(__webpack_require__.s = 0);
        /******/
    })
    /************************************************************************/
    /******/
    ([
        /* 0 */
        /***/
        (function(module, exports, __webpack_require__) {

            "use strict";


            var extractCookies = __webpack_require__(1);

            function toRequestHeaders(req) {
                return function(headerOverrides) {
                    var headers = Object.assign({}, headerOverrides);
                    var cookies = Object.assign({}, req.cookies);

                    if (req.aspects) {

                        if (req.aspects['web-context'] && req.aspects['web-context'].requestId) {
                            headers['x-wix-request-id'] = req.aspects['web-context'].requestId;
                        }

                        if (req.aspects['web-context'] && req.aspects['web-context'].language) {
                            headers['x-wix-language'] = req.aspects['web-context'].language;
                        }

                        if (req.aspects['web-context']) {
                            Object.assign(headers, req.aspects['web-context'].export().headers);
                        }

                        if (req.aspects['petri']) {
                            var petriCookies = req.aspects['petri'].export().cookies || [];
                            petriCookies.forEach(function(_ref) {
                                var key = _ref.key,
                                    value = _ref.value;
                                return cookies[key] = value;
                            });

                            if (req.aspects['petri'].overrides && Object.keys(req.aspects['petri'].overrides).length > 0) {
                                var overrides = req.aspects['petri'].overrides;
                                headers['x-wix-petri-ex'] = Object.keys(overrides).map(function(k) {
                                    return k + ':' + overrides[k];
                                }).join(';');
                            }
                        }
                    }

                    if (req.headers && req.headers['x-xsrf-token']) {
                        headers['x-xsrf-token'] = req.headers['x-xsrf-token'];
                    }

                    if (Object.keys(cookies).length > 0) {
                        var serialized = Object.keys(cookies).map(function(key) {
                            return key + '=' + cookies[key];
                        });
                        headers['cookie'] = serialized.join(';');
                    }

                    return headers;
                };
            }

            function fromResponse(req) {
                return function(responseHeaders) {
                    var aspects = req.aspects || {};
                    var responseData = {
                        headers: responseHeaders,
                        cookies: extractCookies(responseHeaders)
                    };

                    Object.keys(aspects).forEach(function(key) {
                        if (typeof aspects[key].import === 'function') {
                            aspects[key].import(responseData);
                        }
                    });
                };
            }

            module.exports = {
                toRequestHeaders: toRequestHeaders,
                fromResponse: fromResponse
            };

            /***/
        }),
        /* 1 */
        /***/
        (function(module, exports, __webpack_require__) {

            "use strict";


            var cookie = __webpack_require__(2);

            function extractCookies(headers) {
                return ([headers['set-cookie']] || []).reduce(function(prev, curr) {
                    return prev.concat(curr);
                }, []).map(function(c) {
                    return c && cookie.parse(c);
                }).reduce(function(prev, curr) {
                    return Object.assign(prev, curr);
                }, {});
            }

            module.exports = extractCookies;

            /***/
        }),
        /* 2 */
        /***/
        (function(module, exports, __webpack_require__) {

            "use strict";
            /*!
             * cookie
             * Copyright(c) 2012-2014 Roman Shtylman
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */



            /**
             * Module exports.
             * @public
             */

            exports.parse = parse;
            exports.serialize = serialize;

            /**
             * Module variables.
             * @private
             */

            var decode = decodeURIComponent;
            var encode = encodeURIComponent;
            var pairSplitRegExp = /; */;

            /**
             * RegExp to match field-content in RFC 7230 sec 3.2
             *
             * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
             * field-vchar   = VCHAR / obs-text
             * obs-text      = %x80-FF
             */

            var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

            /**
             * Parse a cookie header.
             *
             * Parse the given cookie header string into an object
             * The object has the various cookies as keys(names) => values
             *
             * @param {string} str
             * @param {object} [options]
             * @return {object}
             * @public
             */

            function parse(str, options) {
                if (typeof str !== 'string') {
                    throw new TypeError('argument str must be a string');
                }

                var obj = {}
                var opt = options || {};
                var pairs = str.split(pairSplitRegExp);
                var dec = opt.decode || decode;

                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i];
                    var eq_idx = pair.indexOf('=');

                    // skip things that don't look like key=value
                    if (eq_idx < 0) {
                        continue;
                    }

                    var key = pair.substr(0, eq_idx).trim()
                    var val = pair.substr(++eq_idx, pair.length).trim();

                    // quoted values
                    if ('"' == val[0]) {
                        val = val.slice(1, -1);
                    }

                    // only assign once
                    if (undefined == obj[key]) {
                        obj[key] = tryDecode(val, dec);
                    }
                }

                return obj;
            }

            /**
             * Serialize data into a cookie header.
             *
             * Serialize the a name value pair into a cookie string suitable for
             * http headers. An optional options object specified cookie parameters.
             *
             * serialize('foo', 'bar', { httpOnly: true })
             *   => "foo=bar; httpOnly"
             *
             * @param {string} name
             * @param {string} val
             * @param {object} [options]
             * @return {string}
             * @public
             */

            function serialize(name, val, options) {
                var opt = options || {};
                var enc = opt.encode || encode;

                if (typeof enc !== 'function') {
                    throw new TypeError('option encode is invalid');
                }

                if (!fieldContentRegExp.test(name)) {
                    throw new TypeError('argument name is invalid');
                }

                var value = enc(val);

                if (value && !fieldContentRegExp.test(value)) {
                    throw new TypeError('argument val is invalid');
                }

                var str = name + '=' + value;

                if (null != opt.maxAge) {
                    var maxAge = opt.maxAge - 0;
                    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
                    str += '; Max-Age=' + Math.floor(maxAge);
                }

                if (opt.domain) {
                    if (!fieldContentRegExp.test(opt.domain)) {
                        throw new TypeError('option domain is invalid');
                    }

                    str += '; Domain=' + opt.domain;
                }

                if (opt.path) {
                    if (!fieldContentRegExp.test(opt.path)) {
                        throw new TypeError('option path is invalid');
                    }

                    str += '; Path=' + opt.path;
                }

                if (opt.expires) {
                    if (typeof opt.expires.toUTCString !== 'function') {
                        throw new TypeError('option expires is invalid');
                    }

                    str += '; Expires=' + opt.expires.toUTCString();
                }

                if (opt.httpOnly) {
                    str += '; HttpOnly';
                }

                if (opt.secure) {
                    str += '; Secure';
                }

                if (opt.sameSite) {
                    var sameSite = typeof opt.sameSite === 'string' ?
                        opt.sameSite.toLowerCase() : opt.sameSite;

                    switch (sameSite) {
                        case true:
                            str += '; SameSite=Strict';
                            break;
                        case 'lax':
                            str += '; SameSite=Lax';
                            break;
                        case 'strict':
                            str += '; SameSite=Strict';
                            break;
                        default:
                            throw new TypeError('option sameSite is invalid');
                    }
                }

                return str;
            }

            /**
             * Try decoding a string using a decoding function.
             *
             * @param {string} str
             * @param {function} decode
             * @private
             */

            function tryDecode(str, decode) {
                try {
                    return decode(str);
                } catch (e) {
                    return str;
                }
            }


            /***/
        })
        /******/
    ]);
});